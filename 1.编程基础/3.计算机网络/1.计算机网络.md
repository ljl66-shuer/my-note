# 1.OSI 与 TCP/IP 各层的结构与功能, 都有哪些协议

```bash
OSI七层协议:应用层、表示层、会话层、运输层、网络层、数据链路层、物理层
TCP/IP四层协议：应用层、运输层、网际层、网络接口层
五层体系：应用层、运输层、网络层、数据链路层、物理层
```

**应用层**：通过应用进程间的交互来完成特定网络应用。 协议：DNS(域名系统)、HTTP协议、SMTP(支持电子邮件)。 数据单位：**报文**

**表现层**：提供各种应用于应用层数据的编码和转换功能，数据压缩和加密也是表示层可提供的转换功能之一。

**会话层**：会话层就是负责建立、管理和终止表示层实体之间的通信会话

**运输层**：负责向两台主机进程之间的通信提供通用的数据传输服务。TCP(面向连接、可靠)、UDP(无连接)。数据单位：**分组** 

**网络层**：选择合适的网间路由和交换结点， 确保数据及时传送。IP、ICMP、IGMP。 数据单位：IP数据报

**数据链路层**：网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。 ARP(地址解析)、RARP。 数据单位：**帧**

**物理层**：实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。数据单位：比特



# 2.TCP三次握手和四次挥手

```bash
- 三次握手：
	三次握手的目的是建立可靠的通信信道，也就是双方确认自己与对方的发送与接收是正常的。
	1.客户端发送带有Syn同步标志(seq=x)的数据包给服务端。 第一次握手Client什么都不能确认，Server端确认对方发送正常，自己接收正常。客户端进入SYN_SEND状态。
	2.服务端收到SYN同步报文后，回复带有SYN(seq=y)和ACK(ack=x+1)标志的数据包给客户端。(服务端进入SYN_RCVD状态) 第二次握手Client确认了：自己发送、接收正常，对方发送、接收正常；[确认序号为收到的序号加 1](客户端进入ESTABLISED状态)
	3.客户端收到服务器端的SYN报文，回应一个ACK（ack=y+1;seq=x+1）报文，完成握手连接。 第三次握手Server确认了Client方发送和接收都正常。(服务端进入ESTABLISED状态)
	所以经过三次握手，双方就可以确认双发收发功能都正常。
	
- 问题
	1. 第 2 次握手传回了 ACK，为什么还要传回 SYN？
	接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。”
	2.为什么TCP采用3次握手而不采用2次握手
	1）三次握手可以建立可靠的传输链路。2次握手不能保证双方的接发功能都正常，只能保证一方，所以不可靠。
	2）`为了防止已失效的连接请求报文突然又传送到了服务器，从而产生错误。`(2次握手，如果由于网络原因，客户端迟迟收不到确认报文，会重新发送，如果等网络通畅后，本该失效的连接请求成功连接到服务器，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费)
```

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220111225343576.png" alt="image-20220111225343576" style="zoom:67%;" />

```bash
- 四次握手
	1.客户端-发送一个 FIN 报文，用来关闭客户端到服务器的数据传送。客户端处于半关闭状态，客户端不能发送数据，但是依然可以接受来自服务端的数据。
	2.服务器-收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号。发送这个ACK是因为防止客户端重新发送FIN报文。
	3.服务器-等待服务器的数据都发送完毕后，关闭与客户端的连接，发送一个 FIN 给客户端
	4.客户端-收到FIN报文后，发回 ACK 报文确认，并将确认序号设置为收到序号加 1。注意客户端发出确认报文后不是立马释放TCP连接，而是要经过2MSL(最长报文段寿命的2倍时长)后才释放TCP连接。而服务端一旦收到客户端发出的确认报文就会立马释放TCP连接，所以服务端结束TCP连接的时间要比客户端早一些。
-状态变化
	1.客户端发送fin报文，进入FIN-WAIT-1状态
	2.服务端收到并发送ACK，进入CLOSE-WAIT状态
	3.客户端收到客户端进入FIN-WAIT-2状态
	4.服务端发送fin报文，进入LAST-ACK状态
	5.客户端收到并发送ack，客户端进入TIME-WAIT状态
	6.服务端收到ack，进入CLOSE状态

- 问题
	1.为什么客户端最后还要等待2MSL？
	首先MSL(maximum segment life)是TCP报文的最长存活时间，这样做有两个原因：1）客户端发送ACK响应报文时，如果报文快要服务端时丢失，此时服务端重新发送FIN 结束报文，此时客户端从发送ACK到重新收到FIN报文经历了2MSL。那么客户端会重新发送ACK报文。2)MSL可以防止与“3次握手”中已失效连接的问题，因为发送完确认报文后，等待2MSL后，可以使所有已发送但未抵达的连接报文全部失效。这样新的连接中不会出现旧连接的请求报文。
	2.为什么建立连接是三次握手，关闭连接确是四次挥手呢？
	建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
	而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。
	3.如果已经建立了连接，但是客户端突然出现故障了怎么办？
	TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。
	
TCP短连接(HTTP 1.0)	
	请求连接，建立连接，发送消息，回应消息，请求完成，连接结束。即一次TCP请求。
TCP长连接(HTTP 1.1)
	client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。这个连接并不是永久有效，如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，探测显示客户端正常，则服务器将保活定时器复位；如果客户端异常断开，则TCP断开。
```

# 3.TCP和UDP的区别

```bash
他们都是传输层协议。
服务：TCP是面向连接的服务，UDP是无连接的服务。
可靠：TCP为保证传输的可靠，会有三次握手、四次挥手等方式，UDP没有确认机制和重传机制，可能会丢包
速度：TCP传输慢，而UDP速度快。TCP是面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的；UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低
对象：TCP连接时点对点的，而UDP支持一对一、一对多、多对一和多对多的交互通信
应用：TCP一般应用于可靠性要求高的场景，比如文件传输、发送和接收邮件、远程登录等场景；UDP应用于高速传输和可靠性不高的场景，比如直播、视频电话、语音电话。
首部字节：TCP首部开销20字节;UDP的首部开销小，只有8个字节
```

# 4.TCP如何保证可靠传输

1. 应用数据被分割成TCP认为最合适发送的数据块，然后TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层

3. **校验和**：TCP 将保持它首部和数据的检验和。目的是检测数据在传输过程中的任何变化
4. **ARQ协议**：自动重传请求(Automatic Repeat-reQuest)是错误纠正协议之一。它通过使用确认和超时这两个机制。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。分为停止等待ARQ和连续ARQ。
   * 停止等待ARQ：每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间，还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。
   * 连续ARQ：可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。
5. **滑动窗口和流量控制**：TCP 利用滑动窗口实现流量控制。**流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。
5. **拥塞控制**：当网络拥塞时，减少数据的发送。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。**拥塞控制就是为了防止过多的数据注入到网络中。**为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

# 5.在浏览器中输入 url 地址 >> 显示主页的过程

总体来说分为以下几个过程：

1.DNS解析	2.TCP连接	3.发送HTTP请求	4.服务器服务器处理请求并返回HTTP报文 5.浏览器解析渲染页面 6.连接结束

## 5.1 DNS解析

**1）什么是DNS协议**

DNS：Domain Name System，域名系统，用于将域名转换成IP地址，属于应用层的协议。而ARP是ip地址转换成MAC地址，是网络层和数据链路层之间的协议。

由于用户更喜欢记忆域名，网络设计者于是做了权衡，即一个网址到IP地址的转换就是DNS解析；HTTP是基于TCP连接的，而TCP则是通过IP地址去识别访问的。DNS解析就是域名转换成ip地址的过程。

**2）域名解析过程**

​	递归查询：首先本机向本地域名服务器发出一次查询请求，然后等待结果。如果本地域名服务器无法解析，它就会以DNS客户机的身份向其它域名服务器查询，直到查到得到最终IP告诉本机。

​	迭代查询：本地域名服务器向根域名服务器查询，根域名服务器告诉它下一步到哪里去查询，然后它再去查，每次它都是以客户机的身份去各个服务器查询。

​	最后为了方便下次查询，会将结果存入==**DNS高速缓存**==中。

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220121211648452.png" alt="image-20220121211648452" style="zoom:80%;" />

3）DNS缓存

**浏览器缓存->系统缓存(hosts文件)->路由器缓存**->ISP服务器缓存->根域名服务器缓存->顶级域名服务器缓存->主域名服务器缓存

## 5.2 TCP连接

**TCP三次握手**：客户端发送syn(x)报文，服务器收到发送syn(y)和ack(x+1)，客户端收到发送ack(y+1)。

## 5.3 HTTP连接

```bash
- 请求报文
	格式：请求行 请求头 空行 请求体
	请求行：请求方法 请求路径 协议版本号。 例如：GET /home HTTP/1.1	|  	POST /home HTTP/1.1
	请求头：以键值对的形式，例如：
		Content-Type: text/html; charset=utf-8 可以设置请求的编码方式
		Content-Length：10 定长数据传输，此信息很关键
		Connection:keep-alive 表示HTTP1.1 是长连接
	请求体：post请求才会用到请求体。
- 响应报文
	格式：响应行 响应头 空行 响应体
	响应头：协议版本号 状态码 状态值	HTTP/1.1 200 OK
	响应头：类似请求头
		Content-Type: applacation/json 设置响应的形式
	响应体：类似请求体
- 请求方式：GET、POST、PUT、DELETE等
	- POST请求和GET请求区别
		1.从缓存角度，get请求会被浏览器主动缓存下来，post不会
		2.从幂等性角度，get具有幂等性，post不具有幂等性(幂等性：http定义幂等性是指一次和多次请求某一个资源应该具有同样的作用)(幂等表示执行相同的操作，结果也是相同的)
		3.从参数角度，get请求一般参数放在url上，不安全，post放在请求体中更安全
		4.从容量角度，get请求参数有长度限制，post理论上没有
		5.从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)
- URI和URL
	URI[[Uniform Resource Identifier]:统一资源标识符，用来唯一标识一个资源
	URL[Uniform Resource Location]:统一资源定位符，是一种具体的URI，因为URL不仅标识了一个资源还指名了如何定位一个资源。
	1.关系：URI是URL的更高层次的抽象，URL是URI的具体获取实现。打个比方，URI如同身份证表示了一个独一无二的人，URL则表示了这个人的地址，可以通过URL找到这个人。
	2.URL格式：协议 ip:端口 资源具体位置
		- ftp://106.15.192.190:7721
	3.URI编码：只能支持ASCII。对于非ASCII字符，需要转为16进制数值并在前面加上%	
- 状态码
	1xx:协议处理的中间状态，还需要后续操作
	2xx:表示成功状态
	3xx:表示重定向状态
	4xx:客户端错误，请求报文有误等
	5xx:服务器错误，服务器处理请求发生错误
	举例:200表示客户端发送给服务器的请求被正常处理并返回；表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容
	301永久性重定向；302 临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；
	400 表示请求报文中存在语法错误；401 未经许可，需要通过HTTP认证；403服务器拒绝该次访问；404表示服务器上无法找到请求的资源
	500 表示服务器在执行请求时发生了错误
- 优点
	1.灵活可扩展。传输形式多样，除了文本还可以是图片或者视频；语义自由，语法限制少。
    2.可靠传输。HTTP是基于TCP协议的，所以继承了TCP的可靠传输。
    3.请求-应答。
    4.无状态。每次http请求都是独立、无关的，默认不需要保留状态信息。
- 缺点
	1.无状态：需要辩证看待。在长连接场景下，需要保存大量上下文信息，所以缺点；有时只是为了获取一些数据，无状态减少网络开销，就是优点了。
	2.明文传输：暴露给外界，容易受到攻击
	3.队头阻塞：基于`请求-应答`模式进行的，报文必须是一发一收，里面的任务被放在一个任务队列中串行执行，一旦队首请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。
		- 解决方法
			1.并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个任务队列阻塞其他任务。
			2.域名分片：一个域名可以并发6个长连接。那么多分几个域名。分出多个二级域名，而他们都指向同样一台服务器，能够并发的长连接数就更多了。比如 content1.sanyuan.com、content2.sanyuan.com。就是sanyuan.com下分片的               二级域名		 
		- 小知识：
			域名分为顶级域名、一级域名、二级域名。顶级域名就是一级域名，比如.com .org .cn。N级域名就是在一级域名的前面			追加一级。
- HTTP代理
	一般是由客户端发送请求，服务器响应请求。特殊情况，就是代理服务器的情况。引入代理之后，作为代理服务器相当于一个中间人的角色。对于客户端，表现为服务器进行响应；对于源服务器，表现为客户端发起请求，具有双重身份
```

> 正向代理、反向代理

**正向代理**

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220121224925624.png" alt="image-20220121224925624" style="zoom:80%;" />

**正向代理**是帮助客户端访问客户端访问不到的服务器，然后将结果返回给服务器。(VPN)

特点：服务器只清楚请求来自哪个代理服务器，而不清楚来自具体的客户端。正向代理隐藏了真实客户的信息。

**反向代理**

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220121225013508.png" alt="image-20220121225013508" style="zoom:80%;" />

**反向代理**是帮助服务器接收来自其他客户端的请求。客户端访问代理服务器，代理服务器去访问真正的服务器地址。

例如淘宝，每天访问量很大，不可能只用单个服务器处理所有业务，于是出现了分布式部署。也就是通过部署多台服务器来解决访问人数限制的问题。客户端请求taobao.com，DNS服务器把域名解析到nginx服务器上（简单的这么理解），nginx服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了。

反向请求的来源也就是客户端是明确的，但是请求的具体由哪台服务器处理并不明确，nginx扮演的就是一个反向代理角色。

> 什么是跨域？

uri: scheme://user:pass@host:port/path?query

首先，只有在前后端分离时才会遇见跨域问题，没做前后端分离的项目是遇不见跨域问题的。其次，跨域问题的出现是因为浏览器的同源策略拒绝了我们的请求。即出现协议、主机ip、端口中存在不一样的请求。最后，浏览器为什么会有跨域策略，是为了防止同时打开的多个网址，其中一个网址拿另一个网址的信息去访问A网址。

首先了解浏览器的同源政策(scheme、host、port相同则为同源)。

非同源站点有这样的限制：

* 不能修改和读取对方的DOM
* 不能访问对方的Cookie、IndexDB
* 限制XMLHttpRequest请求

当浏览器向目标URL发送Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被称为跨域请求。

**解决跨域**

1. Nginx是一个高性能的反向代理服务器，可以轻松解决跨域问题。

## 5.4 HTTP响应

## 5.5 浏览器解析渲染页面

HTML、CSS、JS。

浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。如果遇到请求外部资源时，由于请求是异步的，并不会影响HTML加载，加载时遇见JS文件，HTML文档会挂起渲染过程，要等到JS加载并JS解析完，才会继续HTML渲染，原因是因为JS有可能修改DOM结构。

## 5.6 连接结束

TCP四次挥手。

# 6.HTTP1.0 HTTP1.1 HTTP2.0

## 6.1长连接、短连接

在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。每次重新建立连接，都要重新建立HTTP会话。

而从HTTP/1.1 起默认使用长连接，用以保持连接特性。请求头或响应头中会有`Connection:keep-alive`，在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。长连接并不会永久保持连接，它有一个保持时间。长连接利用的是TCP的长连接。

**HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。**

## 6.2 区别

1.HTTP1.0 使用短连接。HTTP1.1 使用长连接。

2.在HTTP1.1中新增了24个错误状态响应码

3.HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分

4.HTTP2.0采用的是多路复用技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。

5.HTTP2.0对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快

6.HTTP2.0引入了server push，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。

# 7.HTTP与HTTPS区别

1. 端口: HTTP:80 HTTPS:443
2. 安全性和资源消耗:HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/**TLS** 之上的 HTTP 协议，SSL/**TLS** 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。 

```bash
- 请求超时
	如果是第一次的话，则是TCP的三次握手建立连接，如果这个过程中发生了ack确认报文的超时，则会发生请求超时。
	我理解的是，TCP建立完成后，发送HTTP请求，服务端会立即发送ack确认报文，告诉客户端收到。
	setConnectionTimeout
- 响应超时
	HTTP的响应超时则是建立完TCP连接后，服务器迟迟没有处理完任务，进而发送响应报文很慢。导致超过了客户端设置的响应报文的超时时间。
	setReadTimeout
```

# 8.HTTPS

==**HTTPS = HTTP + TLS/SSL**==   非对称解密传输对称加密

SSL：（Secure Socket Layer） 安全套接层；TLS:（Transport Layer Security）传输层安全性协议。TLS是SSL的发展和改进。

HTTPS是为了解决HTTP的不安全问题。在HTTP的传输过程中，任何人都可以从中捕获、修改或者伪造请求发送，所以HTTP是不安全的；HTTP不会验证通信方身份，也不会验证报文的完整性。HTTPS应运而生。

## 8.1 TLS

三个关键指标：**加密**(Encryption)、**数据完整性**(Data integrity)、**身份认证**(Authentication)。

> 加密(Encyption)

在通信刚开始时使用非对称加密，解决`密钥交换`问题，然后用随机数产生对称算法使用的`会话密钥(session key)`，在用`公钥加密`，对方拿到密文后用`私钥解密`,取出会话密钥。接下来双方就实现了对称密钥的安全交换。

> 完整性

实现完整性的手段是`摘要算法`。MD5全称是`message digest algorithm 5`，它属于`密码哈希算法`的一种，可将任意长度的字符串创建128位字符串值。MD5最常用于`验证文件完整性`.

安全性更高的加密方式HMAC。如果文件改变了一个标点符号，或者增加一个空格，生成的文件摘要都不一样。

> 认证

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20211010152858994.png" alt="image-20211010152858994" style="zoom:80%;" />

**对通信双方身份的认证。**防止中间人攻击。核心原因:**客户端无法确认公钥是不是真的是服务端发来的**。为了解决这个问题，需要引入公信机构，就是CA机构。**CA认证**

服务端在使用HTTPS前，去经过认证的CA机构申请办法一份**数字证书**，数字证书中包含了**公钥**、有效期等信息，服务端将证书发送给客户端，客户端验证证书身份和要访问的网站身份一致后进行后续操作。

为了解决中间人只改动公钥部分，引入了防伪技术。公钥加密，只有私钥能解密(传输密钥)，所以私钥加密也只有公钥能解开(不可更改)。私钥除了可以做解密外，还可以用作数字签名(用私钥加密，公钥解密)，有人篡改了公钥部分还是数字签名都会导致客户端在验证证书时失败。具体过程：

1. CA机构拥有自己的一对公钥和私钥
2. CA机构在颁发证书时对证书明文信息进行哈希
3. 将哈希值用私钥进行加密，得到数字签名

**明文数据**(服务端公钥、哈希算法、其他信息)和**数字签名**组成证书，传递客户端。

1. 客户端得到证书后，分解为明文部分和数字签名Sig1
2. **用CA机构的公钥进行解签**，得到哈希值h1(由于CA机构是一种公信身份，因此在**系统和浏览器中会内置CA机构的证书和公钥信息**，自动用此CA机构和公钥进行解密)
3. 用**证书内置的哈希算法**对明文Text部分进行哈希得到h2
4. 用自己计算的**h2和解签得到的h1**比较，相等则证书可靠，没有被篡改。

```bash
问题1： 中间人更换了证书中的服务器公钥和数字签名为自己的，如何解决的？
原因1: 首选此问题出在没有认识到CA机构的作用，CA机构拥有自己的一对公钥和私钥，数字签名只能有此CA机构的公钥才能解码，而且这个过程浏览器和系统中内置了CA机构的公钥信息，所以解码时一定用的是CA机构的公钥解码而不是明文部分的公钥，明文部分的公钥是服务端的公钥信息，不是CA机构的。
问题2： 如果我自己创建一个证书(包含证书的公钥信息)，放到另一台机器上，在没有黑客入侵电脑的情况下，HTTPS安全嘛？
原因2： 此证书中包含的服务器公钥以及证书公钥，所以识别到此证书后，用证书公钥进行解码，则也能保证安全性。但是这个服务器就可以充当中间人攻击安装它的私人证书的用户。还是有风险的

- 数字证书
	数字证书包括了明文信息(服务器公钥、哈希算法、有效期等其他信息)和数字签名
- 数字签名
	是对数字证书的明文信息使用证书中的哈希算法进行哈希操作，得到字符串h，再将字符串h利用证书的私钥进行加密，得到数字签名。只有公钥才能解密，而且这个部分理论上来说是无法更改的或者更改就出问题。
```

## 8..2 HTTPS通信流程

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220122114135751.png" alt="image-20220122114135751" style="zoom:80%;" />

1. 用户在浏览器发起HTTPS请求（如 [juejin.cn](https://juejin.cn/user/747323638163768)），默认使用服务端的443端口进行连接；
2. HTTPS需要使用一套**CA数字证书**，证书内会附带一个**公钥Pub**，而与之对应的**私钥Private**保留在服务端不公开；(申请证书)
3. 服务端收到请求，返回配置好的包含**公钥Pub**的证书给客户端；(返回证书)
4. 客户端收到**证书**，校验合法性，主要包括是否在有效期内、证书的域名与请求的域名是否匹配，数字签名进行验证(验证方式见认证内容 )，上一级证书是否有效（递归判断，直到判断到系统内置或浏览器配置好的根证书），如果不通过，则显示HTTPS警告信息，如果通过则继续；(CA认证)**==加密、数据完整性、身份认证==**
5. 客户端生成一个用于对称加密的**随机Key(Session Key)**，并用证书内的**公钥Pub**进行加密，发送给服务端；(非对称加密)
6. 服务端收到**随机Key(Session Key)**的密文，使用与**公钥Pub**配对的**私钥Private**进行解密，得到客户端真正想发送的**随机Key(Session Key)**；(非对称加密)
7. 服务端使用客户端发送过来的**随机Key(Session Key)**对要传输的HTTP数据进行对称加密，将密文返回客户端；(对称加密)
8. 客户端使用**随机Key(Session Key)**对称解密密文，得到HTTP数据明文；(对称加密)
9. 后续HTTPS请求使用之前交换好的**随机Key(Session Key)**进行对称加解密。(对称加密)
10. 

# 9.SSH

SSH(Secure Shell)  ==**非对称加密**==

内容：加密、中间人攻击、公钥登陆、数据传输。

ssh主要用作**远程登陆、数据传输。**

> 加密

加密的意思是一段数据**经过处理**之后，输出一段外人无法或者很难破译的数据，除了**指定的人**可以**解密**。

主流的加密算法:

* 私钥加密,也称对称加密
* 公钥加密，也称非对称加密(ssh使用此加密方式)

**私钥加密**(对称加密)

私钥加密，是加密方和解密方用的都是同一个key，这个key对于加密方和解密方来说是保密的，第三方是不能知道的。一般来说，加密方式先产生一个私钥，然后通过一个安全的途径来告知解密方这个私钥。

**公钥加密**(非对称加密) 

解密的一方首先要产生一对密钥，一个私钥和一个公钥，私钥不会泄露出去，而公钥则是可以任意的对外发布。用公钥加密的数据，只能用私钥才能解密。加密方首先从解密方获取公钥，然后利用这个公钥进行加密，把数据发送给解密方。解密方利用私钥进行加密，如果解密的数据在传输过程中被第三方解惑，也不用担心，因为第三方没有私钥，没有办法进行解密。

公钥加密问题：加密方在获取公钥之后，如何确定公钥来自确定的一方，而不是某个冒充的机器。假设公钥不是来自我们信任的机器，那么就算我们用公钥加密也没有用，因为加密之后的数据是发给冒充的机器，该机器就可以利用它产生私钥进行解密了。所以公钥加密里面比较重要的一步就是**身份认证**。

>数据传输

1. 客户端发起链接请求
2. 服务端返回自己的公钥，以及一个会话ID（这一步客户端得到服务端公钥）
3. 客户端生成密钥对
4. 客户端用自己的公钥异或会话ID，计算出一个值，并用服务端的公钥加密
5. 客户端发送加密后的值到服务端，服务端用私钥解密
6. 服务端用解密后的值异或会话ID，计算出客户端的公钥（这一步服务端得到客户端公钥）
7. 至此，双方各自持有三个秘钥，分别为自己的一对公、私钥，以及对方的公钥，之后的所有通讯都会被加密

> 数据一致性/完整性

如何保证一段数据在传输过程中没有遗漏、破坏或者修改过。一般来说，目前比较流行的做法是对数据进行hash，得到的hash值和数据一起传输，然后在收到数据也对数据进行hash，**将得到的hash值和传输过来的hash进行对比**，如果不一样，说明数据已被修改过；如果不一样，则说明极可能是完整的，

目前比较流行的hash算法是**MD5**和**SHA-1**算法

> 基本流程/密码登陆

1. 服务端收到登录请求后，首先互换秘钥，详细步骤如上一节所述。
2. 客户端用服务端的公钥加密账号密码并发送
3. 服务端用自己的秘钥解密后得到账号密码，然后进行验证
4. 服务端用客户端的公钥加密验证结果并返回
5. 服务端用自己的秘钥解密后得到验证结果

> 身份认证/公钥登陆

密码登陆，就需要每次都输出密码，有些麻烦。使用公钥登陆，可以省去输入密码的过程。

1. 客户端用户必须手动地将自己的公钥添加到服务器一个名叫authorized_keys的文件里，顾名思义，这个文件保存了所有可以远程登录的机器的公钥。
2. 客户端发起登录请求，并且发送一个自己公钥的指纹（具有唯一性，但不是公钥）
3. 服务端根据指纹检测此公钥是否保存在authorized_keys中
4. 若存在，服务端便生成一段随机字符串，然后利用客户端公钥加密并返回
5. 客户端收到后用自己的私钥解密，再利用服务端公钥加密后发回
6. 服务端收到后用自己的私钥解密，如果为同一字符串，则验证通过

> 中间人攻击

虽然ssh协议在被中途截获仍具有安全性，但是如果截获登陆请求后，恶意冒充远程主机，通过公钥获取登陆密码，用这个密码登陆远程主机，那么ssh便不安全了。

因为不像https协议，ssh协议没有证书中心(CA)签证，也就是说，SSH的公钥都是自己签发的。

![image-20211009160407655](../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20211009160407655.png)

# 10 Cookie Session Token JWT

**认证**：验证当前用户的身份。互联网中的认证：用户名密码登陆、邮箱登陆、验证码登陆。

**授权**：用户授予第三方应用访问该用户某些资源的权限。实现授权的方式有：cookie、session、token

**凭证**：实现认证和授权的前提是需要一种**媒介**(证书)，来标记访问者的身份。当浏览器没有token时，只能游客身份浏览，有了token则可以用户身份使用。

## 10.1 Cookie

* **由于Http是无状态的协议(对之前的请求没有记忆能力，不会保留任何会话信息)**。

* **cookie是为了使服务端和浏览器进行会话跟踪，从而保持一个状态**
* **cookie存在客户端**。通过response储存在浏览器，下次请求时会自动带上cookie。
* **cookie不可跨域**。在不同域名下不能共享。防止了同时打开多个页面，某个页面窃取另外一个页面的登陆信息进行登陆

```bash
name=value  # 键值对
maxAge		# 失效时间
expires		# 过期时间
httpOnly	# 无法通过 JS 脚本 读取到该 cookie 的信息.一定程度可以防止 XSS 攻击，不是绝对的安全
```

## 10.2 Seesion

* **session是基于cookie实现的，session储存在服务端，cookie储存在客户端**。还有第二种方式**[url重写](https://www.cnblogs.com/Renyi-Fan/p/11012086.html)**。即前端在请求新地址时，将上一个响应报文中的sessionID加到URL后面。可以通过response.encodeURL("地址")实现
* **第一次请求，response在Set-Cookie字段返回sessionID，在cookie中保存，并记录当前域名，下一次请求时自动在request的Cookie字段中传递sessionID。如果没有找到，则说明用户没有登录或者登录失效，如果找到说明已登录可执行后面操作。**
* **SessionID 是连接 Cookie 和 Session 的一道桥梁**

cookie和session的区别：session更安全、cookie只能存字符串而session可以存任意类型、cookie一般时间比较长而session时间较短且客户端关闭就没了、cookie存的数据少而session可以存的数据多

**==缺点：==**

* 负载均衡时，跨域不共享

```bash
session
	1.session其实就是一个ConcurrentHashMap，键值对，通过session.getAttribute("nam e");获得session中设置的参数
	2.session的过期时间是从什么时候开始计算的？是从一登录就开始计算还是说从停止活动开始计算？
		从session不活动的时候开始计算，如果session一直活动，session就总不会过期。从该Session未被访问,开始计时; 一旦Session被访问,计时清0;
http的response的Set-Cookie就是更换当前session_id的值的。request的cookie就是当前浏览器的session_id值。

- 解决session不共享问题
	1.tomcat的session广播
	2.nginx
	3.redis储存session id
```

## 10.3 Token

* **==访问资源接口==**(API)时所需要的资源凭证
* 简单的token由：uid(用户唯一身份标识)、time(当前时间戳)、sign(签名)
* **服务端==无状态化==**、**可扩展性好**，支持移动设备，安全，支持跨程序调用。

**优点**

* 每次请求需要把token放在Http的Header里(get和post都放在url中，post其他参数放在body中)
* **基于 token 的用户认证是一种==服务端无状态==的认证方式**，服务端用解析token的计算时间来换取session的储存空间
* token完全由应用管理，所以可以避开同源政策

流程：浏览器发送用户名和密码->服务端验证用户名和密码成功后，将登陆凭证做**数字签名**，加密之后得到字符串作为token，并返回客户端(==**这里不是浏览器**==)->客户端收到token后，会将其存起来(cookie或者文件储存)->客户端下次请求时需要带着token一起->服务端收到请求后，然后去验证客户端请求里面token，成功后返回请求数据或执行某些行为。

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220122164519063.png" alt="image-20220122164519063" style="zoom:80%;" />

==**token如何进行认证工作的？？？**==

```bash
refresh token: 是另一种token。是为了解决token的时间过期时，需要在重新输入用户名和密码的问题。refresh token是一个有效期很长的token，当token失效时，可以用refresh token来获取新的token并且不需要输入用户名密码。且refresh token储存在服务端的数据库，不向session一样储存在内存中。
```

```bash
区别：
- cookie和session区别
	1.session更安全。session储存在服务端，cookie储存在客户端
	2.cookie只能存字符串而session可以存任意类型
	3.cookie一般时间比较长而session时间较短且客户端关闭就没了
	4.cookie存的数据少而session可以存的数据多
- session和token区别
	1.session是一种记录服务端和客户端会话状态的认证机制；token是一种访问资源接口时的服务端无状态认证机制。
	2.session和token并不矛盾。session更注重有状态的会话，token注重无状态的认证。session一般用于浏览器，下次登录时需要重新输入用户名和密码；token则可以用于无状态的情况，比如客户端等，关掉后下次登录还可直接登录。
	3.session用于认证。token用于用户认证和APP授权。安全性token更高。如果需要共享数据则需要使用token。因为sessionID默认可以获得用户所有权利，且这个数据应该保密不应该分享。
```

个人理解：

* Session主要应用于B/S模式。Token应用于C/S模式。
* Session保存在内存中，服务器有状态；Token是服务器无状态的。
* Cookie侧重于信息的存储，主要是客户端行为。Session 和 Token 侧重于身份验证，主要是服务端行为。

## 10.4 JWT

* JSON Web Token(JWT)是目前比较流行的**跨域认证**解决方案。是一种**认证授权机制**。
* 数字签名中通过密钥加密，所以传递的信息的可靠的。

<img src="../../../../../Program Files/Typora/imgs/1.计算机网络.assets/image-20220122164905435.png" alt="image-20220122164905435" style="zoom:80%;" />

* 认证流程：
  * 用户输入用户名/密码登录，服务端认证成功后，会返回给客户端一个 JWT
  * 客户端将 token 保存到本地（通常使用 localstorage)
  * 当用户希望访问一个受保护的路由或者资源的时候，需要请求头中Authorization:Bear \<token\> 

```bash
- 注意点
	1.JWT使用方式：
		* 放在 HTTP 请求头信息的 Authorization 字段
		* 将JWT放在POST的请求体中
	2.JWT的签名将前两部分使用密钥采用特定的签名算法生成
	3.JWT包含了会话信息，所以减少了数据库查询次数；JWT不使用Cookie，所以不用担心跨域问题。
	4.为了减少盗用，JWT不应该使用HTTP明码传输，而使用HTTPS，而且使用POST，不用GET
	5.JWT缺点：由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效

- 主体：Header(头部)、Payload(负载)、Signature(签名)
	- 头部：是一个json对象，描述元数据
		{
  			"alg": "HS256",	 # 签名算法
 			 "typ": "JWT"	 # token类型
		}
	- 负载：也是一个jon对象，	用来存放实际需要传递的数据
		* iss (issuer)：签发人
		* exp (expiration time)：过期时间
		* nbf (Not Before)：生效时间
		* iat (Issued At)：签发时间
		* jti (JWT ID)：编号
		另外，也可以自己添加一些私有字段，进行传输。由于JWT 默认是不加密的，所以不要放私密信息。
	- 签名：对前两部分的签名，防止数据篡改
    	首先需要一个密钥，这个密钥只有服务器知道。然后采用Header里面指定的签名算法，将头部+"." + 负载 + "." 采用密钥使用签名算法产生签名。至此，就生成了JWT，返回给用户。
    	

JWT:前两部分采用Base64 URL算法变为字符串，再加上生成签名组成。
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 
```

**Token和JWT相同点**：都是访问资源的令牌，都可以用来记录用户信息，都使服务端无状态化，只有验证成功后才能访问受保护的资源

**Token和JWT不同点**：

* Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。
* JWT： 将Header和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据

## 10.5 常见问题

**使用Cookie需要考虑的问题**

* **cookie 无法跨域**
* **移动端对 cookie 的支持不是很好，所以移动端常用的是 token**
* 尽量减少 cookie 的体积，能存储的数据量不能超过 4kb

**使用 session 时需要考虑的问题**

* session储存在服务端，用户较多时，session会占据较多的内存，需要定期去清理过期的session
* 网站采用集群部署时，就会遇见**session共享问题**。因为session只能储存在单个服务器上
* **sessionId 是存储在 cookie 中的，假如浏览器禁止 cookie 或不支持 cookie 怎么办？** 一般会把 sessionId 跟在 url 参数后面即重写 url，所以 session 不一定非得需要靠 cookie 实现

**使用 token 时需要考虑的问题**

* 得到token后，需要查询数据库来获取用户信息，如果觉得查询时间太长，可以放入内存中，比如 redis 很适合你对 token 查询的需求。
* token是很好解决跨域问题的解决方案。同样是认证授权方案
* 移动端更长用的是token

**使用 JWT 时需要考虑的问题**

* JWT不依赖cookie，所以不用担心跨域问题
* JWT默认不加密，所以头部Header和负载Payload部分的内容不要包含私密信息(后端处理)
* JWT最大的优点是服务器不需要在储存Session，而且token验证不需要查询数据库，减少了数据库压力。这也是JWT最大的缺点：由于服务器不需要存储 Session 状态，因此使用过程中无法废弃某个 Token 或者更改 Token 的权限。也就是说一旦 JWT 签发了，到期之前就会始终有效，
* 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

**Seesion共享方案**

**1.基于Tomcat的Session复制**

任何一个服务器上的session发生改变，该节点的都会把这个 session 的所有内容序列化，然后广播给所有其它节点，不管其他服务器需不需要 session ，以此来保证 session 同步。

优点：可容错，各个服务器间 session 能够实时响应。

缺点：会对网络负荷造成一定压力。如果 session 量大的话可能会造成网络堵塞，拖慢服务器性能。

**2.基于Nginx的ip_hash负载均衡**

**采用 Ngnix 中的 ip_hash 机制，将某个 ip的所有请求都定向到同一台服务器上，即将用户与服务器绑定。** 用户第一次请求时，负载均衡器将用户的请求转发到了 A 服务器上，如果负载均衡器设置了粘性 session 的话，那么用户以后的每次请求都会转发到 A 服务器上，相当于把用户和 A 服务器粘到了一块，这就是粘性 session 机制。

**3.基于Redis的Session共享**

其实就是把每次用户的请求的时候生成的sessionID给放到Redis的服务器上。然后在基于Redis的特性进行设置一个失效时间的机制，这样就能保证用户在我们设置的Redis中的session失效时间内，都不需要进行再次登录

* 实现Session共享
* 可以水平扩展
* 不仅可以跨服务器，还可以跨平台。

**4.Session持久化**

将 session 存储到数据库中，保证 session 的持久化

**5.改用JWT替代session**

# 11.如何保证接口幂等性

接口幂等性：同一个接口，多次发出同一个请求，必须保证操作只执行一次

```bash
- 那些场景需要接口幂等性
	支付接口，重复支付会导致多次扣钱；订单接口，同一个订单可能会多次创建。

- 为什么会产生接口幂等性问题
	1.网络波动, 可能会引起重复请求
	2.用户重复操作,用户在操作时候可能会无意触发多次下单交易(双击提交按钮)
	3.页面重复刷新
	4.使用浏览器后退按钮重复之前的操作,导致重复提交表单
	
- 如何保证接口幂等性
	客户端：保证按钮只能按一次；或者点击多次只产生一次效果
	服务端：
		1.在session存放特殊标志：在服务端,生成一个唯一的标识符,将它存入session，同时前端获取这个标识符的值将它写入表单的隐藏中，下次请求时带上，服务器端,获取表单中隐藏字段的值,与session中的唯一标识符比较,相等说明是首次提交,然后将session的唯一标识符更改，不相等则表示是重复提交,不再做处理
		2.防重表：利用唯一主键去做防重表的唯一索引，比如使用订单号作为防重表的唯一索引,每一次请求都根据订单号向防重表中插入一条数据,插入成功说明可以处理后面的业务,后续如果有重复请求,则会因为防重表唯一索引原因导致插入失败,直接返回操作失败
		3.状态机幂等：任务相关的业务会涉及到状态机(状态机变更图)，状态在不同的情况下会发生变更，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，就可以保证幂等。
		
```



# 其他题目

**1.关闭浏览器后，Session就会消失吗**

首先，没有特殊情况，关闭浏览器后Session不会消失，除非程序手动删除。

在关闭浏览器后，Session仍然存在服务器的内存中，所以不会消失。如果之前将Cookie中的SeesionID储存下来了，下次请求时改变HTTP请求头，仍然以此SessionID请求，仍然可以直接请求。但是往往没有储存sessionid，下次请求时，服务器就会分配新的sessionid。

恰恰是这个原因，关闭浏览器后对应的sessionid并没有被删除，迫使服务器为session设置了一个失效时间，当上一次使用session超过这个失效时间，服务器就会认为客户端已经停止了活动，于是就会删除session来节省空间。

**2.一个MTU最大是1500字节，那么最多包含多少的数据**

MTU(max transmission unit)最大传输单元。

ip头部字节大小为20~60，最多数据即1500-20=1480

IPv4的头部结构长度为20字节，若含有可变长的选项部分，最多60字节

TCP头部字节为20字节，UDP则为8字节

